[{"body":"A source component is the origin of a data flow in vhs. Source components create the initial data stream that is processed and modified by the other components in the data flow. A source might read from a local file, a cloud storage location, or capture network data. Information on the sources available in the current release of vhs is available on the reference page here: sources.\nDeveloping a Source There are several architectural requirements that must be considered when developing a source. Most importantly, sources must conform to the the interface defined in flow/source.go and shown below:\n// Source is a data source that can be consumed // by an input pipe. type Source interface { Init(session.Context) Streams() \u003c-chan InputReader } The Init function should handle the initialization and concurrent operation of the source. It will be run in its own goroutine by the vhs flow infrastructure. vhs does not use buffered channels, and all components are expected to run concurrently, so care should be taken to avoid internal deadlocks or contention that could cause blocks or bottlenecks. The Init function should clean up and exit upon receiving a signal on core.Context.Done().\nOther important considerations include:\n A source must provide a constructor. By convention this constructor should accept an argument of type session.Context. This constructor may be trivial. Sources may declare command line flags in newRootCmd() in cmd/vhs/main.go. The values of these flags should be stored in FlowConfig in the session package at core/config.go. These values will then be available within your package as part of the core.Context.  Example The file source is a good example implementation of a source. This source reads data from a file and emits it as a stream of bytes. It is implemented in the file package at file/file.go\n","excerpt":"A source component is the origin of a data flow in vhs. Source …","ref":"/vhs/architecture/source/","title":"Source"},{"body":"The quickest way to see vhs in action is to use the development Docker image in this repo to run a demo.\nPrerequisites The first step is to clone the VHS repository.\ngit clone https://github.com/rename-this/vhs.git You will need a working Docker installation to successfully execute the following commands. You should be able to install Docker from your favorite package manager, or you can see the Docker site for more details.\nOnce you have Docker set up and working, you can build the development container by changing directory into the repository you cloned and running:\n$ make dev This command will build and run a Docker container called vhs_dev that contains a standardized development environment for vhs. It includes the Go toolchain as well as other useful utilities such as curl and jq, among others. The vhs source tree that you cloned will be mounted inside the development container at /go/vhs for convenience. Additionally, if present, your Google Cloud SDK configuration folder (~/.config/gcloud) will be mounted in the container at /root/.config/gcloud and the GOOGLE_APPLICATION_CREDENTIALS environment variable will be set to /root/.config/gcloud/application_default_credentials.json. You may need to ensure that this file exists on your system or change this environment variable to point to your own GCS service account credentials before using the GCS functionality of vhs.\nDemo Setup Open a bash session on the container by running the following command in a terminal:\ndocker exec -it vhs_dev bash In your new bash session, run this script to start a simple echo server and a script that will make an HTTP request to the server once every second using curl.\ncd testdata \u0026\u0026 ./echo.bash This will generate some local HTTP traffic for vhs to capture.\nRun The Demo Open another bash session on the container in a new terminal:\ndocker exec -it vhs_dev bash In this new session, run the following command to build vhs and run it to capture our local HTTP traffic.\ngo build ./cmd/vhs \u0026\u0026 ./vhs --input \"tcp|http\" --output \"json|stdout\" --capture-response --address 0.0.0.0:1111 --middleware ./testdata/http_middleware.bash | jq -R \"fromjson | .body\" 2\u003e /dev/null The output should look something like this:\n\"hello, world 1594678195 [[hijacked 0]]\" \"hello, world 1594678195 [[hijacked 1]]\" \"hello, world 1594678196 [[hijacked 0]]\" \"hello, world 1594678196 [[hijacked 1]]\" \"hello, world 1594678197 [[hijacked 0]]\" \"hello, world 1594678197 [[hijacked 1]]\" \"hello, world 1594678198 [[hijacked 0]]\" \"hello, world 1594678198 [[hijacked 1]]\" \"hello, world 1594678199 [[hijacked 0]]\" \"hello, world 1594678199 [[hijacked 1]]\" \"hello, world 1594678200 [[hijacked 0]]\" Explanation of the Demo We can break down the demo command we just ran to get a better feel for how vhs works and what it can do:\ngo build ./cmd/vhs \u0026\u0026 ./vhs This portion of the command builds the vhs from the source tree and executes the resulting binary\n--input \"tcp|http\"  This portion of the command defines input portion of the data flow for this vhs session. Currently, only one source can be specified for a given vhs session.\nIn this case:\n tcp specifies the TCP data source. This source will capture TCP data off the network. http specifies the HTTP input format. This input format will extract HTTP requests and responses from the captured TCP data streams.  --output \"json|stdout\" This portion of the command specifies the output portion of the data flow for this vhs session. A vhs session may have any number of outputs.\nIn this case:\n json specifies the JSON output format. This output format will serialize the HTTP requests and responses into JSON. stdout specifies the standard output sink. This sink will print the data to the console.  --capture-response This flag tells the TCP input source to capture two-way network traffic (requests and responses) instead of one-way (requests only).\n--address 0.0.0.0:1111 This flag specifies the address and port from which vhs will capture traffic, in the form \u003cIP address\u003e:\u003cport\u003e.\n--middleware ./testdata/http_middleware.bash This flag specifies the middleware to run for this vhs session. Middleware enables users to modify or rewrite data as it passes through vhs from source to sink. The middleware specified here appends \" [[hijacked \u003cHTTP_MESSAGE_TYPE\u003e]]\" to the end of the http request or response body as it passes through vhs. More information on middleware can be found here.\n| jq -R \"fromjson | .body\" This portion of the command pipes the output of vhs to jq for filtering and pretty printing. This functionality is external to vhs. You can find more information on jq here.\n2\u003e /dev/null Discards stderr to keep the demo output clean.\nCommon Use Cases Capture live HTTP traffic to cloud storage ./vhs --input \"tcp|http\" --output \"json|gzip|gcs\" --address 0.0.0.0:80 --capture-response --gcs-bucket-name \u003csome_bucket\u003e --gcs-object-name \u003csome_object\u003e --flow-duration 2m\nThe above command will capture live HTTP traffic on port 80 for 2 minutes and save the captured data as gzipped JSON to Google Cloud Storage (GCS) in the specified bucket and object.\nGenerate HAR file from saved HTTP data ./vhs --input \"gcs|gzip|json --output \"har|stdout\" --gcs-bucket-name \u003csome_bucket\u003e --gcs-object-name \u003csome_object\u003e --flow-duration 15s \u003e harfile.json\nThe above command will “replay” saved HTTP data in gzipped JSON format from the specified GCS bucket and object and produce an HTTP Archive (HAR) file called harfile.json on the local filesystem.\nProvide live HTTP metrics ./vhs --input \"tcp|http\" --address 0.0.0.0:80 --capture-response --prometheus-address 0.0.0.0:8888 --flow-duration 60m\nThe above command will capture live HTTP traffic on port 80 and calculate RED metrics for the captured data in real time. These include metrics on request rate, error rate, and request duration. These metrics will be available on a Prometheus endpoint at port 8888. For more information on metrics see the vhs reference entry on metrics support. The command will run for 60 minutes.\n","excerpt":"The quickest way to see vhs in action is to use the development Docker …","ref":"/vhs/getting-started/","title":"Getting Started"},{"body":"A modifier component operates on an unformatted, unstructured stream of bytes as it passes through vhs. Modifier components are well suited to implementing compression/decompression algorithms, as an example. Modifiers may exist in either the input or output chains of the vhs data flow. Input modifiers and output modifiers must be implemented separately. Information on the input and output modifiers available in the current release of vhs is available here: input modifiers and output modifiers\nDeveloping a Modifier Modifiers are implemented in a slightly different fashion when compared to other vhs components. They do not have an Init function, and are instead implemented as wrappers around an InputReader or OutputWriter. Input modifiers must conform to the InputModifier interface defined in core/input_modifier.go, which is shown below:\n// InputModifier wraps an InputReader. type InputModifier interface { Wrap(InputReader) (InputReader, error) } Output modifiers must conform to the OutputModifier interface defined in core/output_modifier.go, which is shown below:\n// OutputModifier wraps an OtputWriter. type OutputModifier interface { Wrap(OutputWriter) (OutputWriter, error) } Internally, the implementation of a modifier usually entails the creation of a new type that conforms to the requisite interface (InputReader or OutputWriter). This the compression or encoding performed by the modifier will be implemented in the methods of this new type, and the Wrap function required by the modifier interfaces seen above will return this new type.\nOther considerations when developing a modifier include:\n A modifier must provide a constructor. By convention this constructor should take an argument of type session.Context. This constructor may be trivial. Modifiers may utilize command line arguments if necessary. These flags must be declared in newRootCmd in cmd/vhs/main.go. The values of these flags should be stored in FlowConfig in the session package at core/config.go. These values will then be available within your package as part of the core.Context. If a modifier uses any internal goroutines, these must clean up and exit upon receiving a signal on the core.Context.Done() channel.  Example The gzip input and output modifiers provided by vhs are useful examples of the implementation of modifiers. They are implemented as wrappers around the gzip.Reader and gzip.Writer packages from the Go standard library package compress/gzip. Many useful modifiers can be implemented in a similar fashion by wrapping other libraries. The implementation of the gzip modifiers is in gzipx/gzipx.go\n","excerpt":"A modifier component operates on an unformatted, unstructured stream …","ref":"/vhs/architecture/modifier/","title":"Modifier"},{"body":"Format components apply structural formats to the data stream as it passes through them. For example, format components may parse a datastream into HTTP requests and responses or format the data stream as JSON or another structured encoding. Formats may exist in either the input or output chains of the vhs data flow. Input formats and output formats must be implemented separately. Information on the input and output formats available in the current release of vhs is available here: input formats and output formats\nDeveloping a Format Internally, the implementation of a format bears some resemblance to that of a source, with the added wrinkle of reading from an incoming channel.\nInput formats must conform to the InputFormat interface as implemented in core/input_format.go and shown below:\n// InputFormat is an interface for formatting input type InputFormat interface { Init(session.Context, middleware.Middleware, \u003c-chan InputReader) Out() \u003c-chan interface{} } An input format must read from a channel of InputReader passed to the Init function and write formatted output to the Out() channel.\nOutput formats must conform to the OutputFormat interface as implemented in core/output_format.go and shown below:\n// OutputFormat is an interface for formatting output type OutputFormat interface { Init(session.Context, io.Writer) In() chan\u003c- interface{} } The output format interface is essentially the reverse of the input format interface. An output format must read interface{} from the In() channel and write bytes to the io.Writer passed to the Init function.\nIn both the input format and the output format, the Init function is responsible for the initialization and internal processing of the format. It will be run in its own goroutine by the vhs flow infrastructure. It may use internal goroutines, but all internal goroutines should clean up and exit upon receipt of a signal on core.Context.Done(). Since formats read and write concurrently, avoidance of deadlocks and bottlenecks is critical. It may be useful to employ two goroutines internally, one to read from the incoming channel and one to write to the outgoing location to avoid contention and blocking.\nOther considerations when developing formats are similar to other components:\n A format must provide a constructor. By convention this constructor should take an argument of type session.Context. This constructor may be trivial. Formats may utilize command line arguments if necessary. These flags must be declared in newRootCmd in cmd/vhs/main.go. The values of these flags should be stored in FlowConfig in the session package at core/config.go. These values will then be available within your package as part of the core.Context. The connection between the input format and the output format is the only location in the vhs data flow that is not strongly typed. Developers should consider this when designing formats and provide documentation indicating the compatibility of their formats with other formats.  Example The json input and output formats are useful examples of input and output format implementations. They are found in the jsonx package at jsonx/jsonx.go.\nThe http input and output formats present more complex examples of formats, including handling of middleware on the input format. They are implemented in the httpx package at httpx/input_format.go and httpx/output_format.go.\n","excerpt":"Format components apply structural formats to the data stream as it …","ref":"/vhs/architecture/format/","title":"Format"},{"body":"Introduction vhs is designed for flexibility and operates on the concept of a data flow that originates with a source and terminates with one or more sinks. Sources may capture network data, read data from files, etc. Sinks may write data to cloud or local storage, standard output, or send data to other destinations. Along the way, data may pass through a series of input modifiers and formats and output modifiers and formats that transform the data. For more information on the technical implementation of vhs, see the architecture overview.\nExample vhs Command ./vhs --inputs \"tcp|http\" --outputs \"json|stdout\" --address 0.0.0.0:8080 --capture-response\nThis command captures two-way TCP data from the network on address 0.0.0.0 and port 8080, extracts HTTP requests and responses from the TCP data, formats them as JSON, and prints them to the standard output.\nSpecifying Inputs and Outputs The core command line flags for vhs are focused on defining the data flow that vhs will use for a recording/replay session. Inputs and outputs are specified in terms of a simple domain specific language that will be detailed in the following sections.\nInputs --input \"\u003csource|modifier(s)|format\u003e\"\nInputs are specified in a pipe-delimited (|), double-quoted string following the --input command line flag. This string must begin with a source, optionally contain modifiers, and end with an input format. The specified source originates a data stream that is modified by the specified modifiers and then formatted, or interpreted by the specified input format.\nIn the example command given above, the input specifier is --inputs \"tcp|http\" where tcp specifies the TCP source and http specifies the HTTP input format. This example does not use any input modifiers.\nOnly one input definition can be specified in a vhs session.\nSources The following sources are currently available:\n tcp file gcs (Google cloud storage) s3compat (S3 compatible cloud storage)  tcp The tcp source captures live TCP/IP network data. It uses the following additional command line flags for configuration:\n --address \u003cip address:port\u003e Required. Specifies the address and port on which vhs will listen. --capture-response Optional. If set, vhs captures requests and responses (2-way traffic).  file The file source reads data from a file on the local filesystem. It requires the following command line flag for configuration. This source reads a file from the filesystem and emits a raw stream of bytes to the modifiers and formats in the specified input chain. These modifiers and formats implement specific support for various file formats. JSON and gzipped-JSON files are currently supported by the available input modifiers and formats.\n --input_file \u003cpath to input file\u003e Required. Specifies the path to the input file to be read.  gcs The gcs source reads data from a Google Cloud Storage object. It requires the following command line flags for configuration. Note that the GCS source also requires Google Cloud authentication credentials to be present on the machine or in the container where vhs is run. The GOOGLE_APPLICATION_CREDENTIALS environment variable can be used to specify the location of the credentials file. For more information on GCS authentication, see Google’s documentation here.\n --gcs-bucket-name \u003cGCS bucket name\u003e Required. Name of bucket that contains the object to be read. --gcs-object-name \u003cobject name\u003e Required. Name of object to be read.  Note that this source also requires a JSON key file containing Google Cloud authentication credentials.\ns3compat The s3compat source reads from an object in an S3-compatible cloud storage location. It requires the following command line flags for configuration.\n --s3-compat-access-key \u003caccess key\u003e Required. Access key for S3 compatible storage. --s3-compat-secret-key \u003csecret key\u003e Required. Secret key for S3 compatible storage. --s3-compat-token \u003ctoken\u003e Required. Session token for S3 compatible storage. --s3-compat-secure Optional. This flag specifies encrypted transport (HTTPS). Default is true. --s3-compat-endpoint \u003cS3 URL\u003e Required. URL for S3-compatible storage. --s3-compat-bucket-name \u003cbucket name\u003e Required. Name of bucket that contains the object to be read. --s3-compat-object-name \u003cobject name\u003e Required. Name of object to be read.  Input Modifiers The following input modifiers are currently available in vhs:\n gzip  gzip The gzip input modifier uncompresses data that has been compressed in the gzip format. It is primarily for use with the file, gcs, and s3compat sources, enabling the reading of compressed files.\nInput Formats The following input formats are currently available in vhs:\n http json  http The http input format decodes the incoming data stream into HTTP requests and responses. This format is primarily intended for use with the tcp source.\njson The json input format interprets the incoming data stream as JSON. It is primarily intended for use with the file and cloud storage sources (gcs and s3compat) for processing data stored in a JSON file.\nOutputs --output \"\u003cformat|modifier(s)|sink\u003e\"\nOutputs are specified in a pipe-delimited (|), double-quoted string following the --output command line flag. The first element in the string must specify an output format, followed by a pipe character, followed by zero or more modifiers separated by pipe characters, followed by another pipe character, and ending with a sink specifier. The output chain works similarly to the input chain. The input format receives the data stream from the end of the input chain and formats or interprets the data. This data can then be modified by an output modifier before it leaves vhs through a sink.\nIn the example command given above, the output specifier is --outputs \"json|stdout\" where json specifies the JSON output format and stdout specifies the standard output sink. This example does not use any output modifiers.\nThe next sections will detail the currently available output format, modifiers, and sink in vhs. Each format, modifier, and sink may require additional configuration in the form of additional command line flags. These will be described where applicable.\nvhs supports an arbitrary number of outputs for any given session. Each output will receive the same data from the input chain.\nOutput Formats The following output formats are currently available in vhs:\n har (HTTP archive) json  har The har output format receives incoming data in the form of a stream of HTTP requests and responses and encodes it into the HTTP Archive (HAR) format. The output of this format can be saved to cloud storage or printed to standard output depending on the sink chosen by the user. For more information on the HTTP Archive format see the specification.\njson The json output format receives incoming data in the form of a stream of HTTP requests and responses and serializes those requests and responses to the JSON format. The output of this format can be saved to cloud storage or printed to standard output depending on the sink chosen by the user.\nOutput Modifiers The following output modifiers are currently available in vhs:\n gzip  gzip The gzip output modifier compresses the data passing through it into the gzip format. This can be used in conjunction with the stdout or cloud storage (gcs or s3compat) sinks to save compressed output data from vhs.\nSinks The following sinks are currently available in vhs:\n gcs (Google cloud storage) s3compat (S3-compatible cloud storage) stdout discard  gcs The gcs sink writes data to a Google Cloud Storage object. It requires the following command line flags for configuration. Note that the GCS sink also requires Google Cloud authentication credentials to be present on the machine or in the container where vhs is run. For more information on GCS authentication, see Google’s documentation here.\n --gcs-bucket-name \u003cGCS bucket name\u003e Required. Bucket name that contains the GCS object to be written to. --gcs-object-name \u003cobject name\u003e Required. Name of object to be read.  s3compat The s3compat sink writes to an object in an S3-compatible cloud storage location. It requires the following command line flags for configuration.\n --s3-compat-access-key \u003caccess key\u003e Required. Access key for S3 compatible storage. --s3-compat-secret-key \u003csecret key\u003e Required. Secret key for S3 compatible storage. --s3-compat-token \u003ctoken\u003e Required. Session token for S3 compatible storage. --s3-compat-secure Optional. This flag specifies encrypted transport (HTTPS). Default is true. --s3-compat-endpoint \u003cS3 URL\u003e Required. URL for S3-compatible storage. --s3-compat-bucket-name \u003cbucket name\u003e Required. Name of bucket that contains the object to be written. --s3-compat-object-name \u003cobject name\u003e Required. Name of object to be written.  stdout The stdout sink writes the data stream it receives to the standard output. This sink can be used in conjunction with shell redirection to save the output of vhs to a file on the local filesystem.\ndiscard The discard sink silently discards the data that is sent to it.\nMiddleware --middleware \u003cpath to middleware executable\u003e\nvhs optionally supports the use of user-supplied middleware to modify data as it passes through vhs. As an example, user supplied middleware could be utilized to remove sensitive user credentials from recorded HTTP data before saving it to cloud storage. Middleware, if used, is placed in the vhs data flow in the output chain between the output format and the output modifiers. It is implemented as a separate binary that will receive formatted data on the standard input and must write modified data on the standard output. A simple example middleware can be found here in the vhs repository.\nPrometheus metrics --prometheus-address \u003cip adddress:port\u003e\nvhs supports calculating metrics on HTTP exchanges captured live from the network. This facility can be used to non-invasively gather metrics for services utilizing HTTP. Specifying the --prometheus-address flag enables metrics support. Metrics support is implemented internally as an output format, and requires an input chain that includes the http input format. A typical command for utilizing the metrics support looks like this:\n./vhs --input \"tcp|http\" --address 0.0.0.0:80 --capture-response --prometheus-address 0.0.0.0:8080\nThis command will capture all http traffic on port 80, calculate metrics, and make them available at a /metrics endpoint on port 8080 of the machine/vm/container running vhs.\nThe provided metrics include measures of request rate, error rate, and request duration, sufficient for implementing the RED method of microservice monitoring. Metrics are supplied on a Prometheus endpoint. Request counts are available in a counter vector labeled with HTTP method, status code, and path. Errors counts are available by querying for HTTP error status codes, and timeouts are counted with empty status codes. Request durations are available in a summary vector with quantiles given in the table below. Durations are also labeled with HTTP method, status code, and path.\n   Quantile Error (+ / -)     50% 5%   75% 1%   90% 0.5%   95% 0.5%   99% 0.1%   99.9% 0.01%   99.99% 0.001%    Complete Command Line Flag Reference    Command line flag Description     –help, -h Show brief help for VHS.   –address string Address VHS will use to capture traffic. (default “0.0.0.0:80”)   –buffer-output Buffer output until the end of the flow.   –capture-response Capture the responses.   –debug Emit debug logging.   –debug-http-messages Emit all parsed HTTP messages as debug logs.   –debug-packets Emit all packets as debug logs.   –flow-duration duration The length of the running command. (default 10s)   –gcs-bucket-name string Bucket name for Google Cloud Storage   –gcs-object-name string Object name for Google Cloud Storage   –http-timeout duration A length of time after which an HTTP request is considered to have timed out. (default 30s)   –input string Input description.   –input-drain-duration duration A grace period to allow for a inputs to drain. (default 2s)   –input-file string Path to an input file   –middleware string A path to an executable that VHS will use as middleware.   –output strings Output description.   –profile-http-address string Expose profile data on this address.   –profile-path-cpu string Output CPU profile to this path.   –profile-path-memory string Output memory profile to this path.   –prometheus-address string Address for Prometheus metrics HTTP endpoint.   –s3-compat-access-key string Access key for S3-compatible storage.   –s3-compat-bucket-name string Bucket name for S3-compatible storage.   –s3-compat-endpoint string URL for S3-compatible storage.   –s3-compat-object-name string Object name for S3-compatible storage.   –s3-compat-secret-key string Secret key for S3-compatible storage.   –s3-compat-secure Encrypt communication for S3-compatible storage. (default true)   –s3-compat-token string Security token for S3-compatible storage.   –shutdown-duration duration A grace period to allow for a clean shutdown. (default 2s)   –tcp-timeout duration A length of time after which unused TCP connections are closed. (default 5m0s)    ","excerpt":"Introduction vhs is designed for flexibility and operates on the …","ref":"/vhs/reference/","title":"Reference"},{"body":"Introduction vhs is a network traffic utility that works by chaining modules loaded from plugins. It offers a high-performance concurrent architecture for routing data and executing modules that enables users to configure and extend vhs for a variety of purposes, including traffic recording, replay, live metrics collection, and many others.\nConcepts The architecture of vhs is built around the concept of a data flow, a directed graph that represents the routing of a stream of data through software components that act on that data stream. In a data flow graph, nodes represent software components that originate, terminate, or modify the data stream passing through them, and edges represent the data stream passing between components.\nIn vhs, the data flow graph looks something like this:\ngraph LR src[Source] in_mod[[Input Modifier]] in_fmt[[Input Format]] out_fmt[[Output Format]] out_mod[[Output Modifier]] sink[Sink] src --\u003e in_mod in_mod --\u003e in_fmt in_fmt --\u003e out_fmt out_fmt --\u003e out_mod out_mod --\u003e sink Where each node represents a particular type of software component and the edges represent the connections between those components. The following two subsections will describe the components and connections that make up the vhs data flow in more detail.\nNodes: VHS Components Each node in the graph represents a concurrently-executed software component. In vhs, these components fall into four categories, as listed below:\n source: source components originate data streams. A source brings data into vhs from somewhere else. This could mean capturing data from a network interface, reading from cloud storage, reading from a local file, etc. More information on the internal architecture of source components can be found here: source architecture. Information about the sources currently available in vhs can be found here: sources. modifier: modifier components modify the data passing through them in its raw format (stream of bytes). Modifiers may exist in either the input chain or the output chain of the vhs data flow, and input and output modifiers are implemented separately. More information about the architecture of modifiers can be found here: modifier architecture. Information about the input and output modifiers currently available in vhs can be found here: input modifiers and output modifiers. format: format components modify or interpret the data passing through them by imposing a format on it, usually in terms of native Go datatypes. Like modifiers, formats may exist in either the input chain or output chain, and input and output formats are implemented separately. More information about the architecture of formats can be found here: format architecture. Information about the input and output formats currently available in vhs can be found here: input formats and output formats. sink: sink components terminate data streams. A sink provides a way for data to leave vhs. This data could be written to a file, stored on cloud storage, transmitted to a network location, etc. More information on the internal architecture of sink components can be found here, and information about the sinks currently available in vhs can be found here.  Additionally, vhs provides an optional facility for middleware. The middleware facility allows users to place their own external modifier code into the vhs data flow. If used, the middleware is placed into the data flow between the output format and the output modifier as shown in the diagram below. This external middleware will receive formatted data in the form of stringified JSON from the chosen output format on stdin and must write modified data to stdout.\ngraph LR src[Source] in_mod[[Input Modifier]] in_fmt[[Input Format]] out_fmt[[Output Format]] mware[[Middleware]] out_mod[[Output Modifier]] sink[Sink] src --\u003e in_mod in_mod --\u003e in_fmt in_fmt -.-\u003e mware mware -.-\u003e out_fmt in_fmt --\u003e out_fmt out_fmt --\u003e out_mod out_mod --\u003e sink style mware fill:#D55E00 Edges: Connections Between Components The edges of the data flow graph represent data streams that pass between components. In vhs, these edges represent the connections between the components described in the previous section. These connections are implemented using channels, a facility for communication between concurrent software components provided by the Go language. At the most basic level, communications between components in vhs utilize two basic strategies. Where raw data streams are needed, vhs uses types from the io package in the Go standard library, specifically the io.ReadCloser interface. Where structured data needs to be passed between components, the empty interface type interface{} is used for maximum flexibility.\nMetadata Sometimes it is useful to pass descriptive information about a data stream between two connected components. For example, the tcp source tracks information about source and destination IP addresses and ports for the tcp streams it captures. This information may be useful to components downstream in the vhs data flow, so vhs provides a key-value metadata facility for recording this type of information and passing it between components. This metadata facility takes the form of a construct called Meta that is implemented in core/meta.go.\nTo pass Meta between components, it is wrapped together with an io.ReadCloser into struct. For example, the InputReader interface is used as the connection between a source and an input modifier. It is defined as follows:\n// InputReader is an input reader. type InputReader interface { io.ReadCloser Meta() *Meta } Metadata is not currently supported on the output chain of the vhs data flow, so the corresponding output interface OutputWriter is much simpler:\n// OutputWriter is an output writer. type OutputWriter interface { io.WriteCloser } Putting this all together, we can see the components and their connections on the following data flow graph:\ngraph LR src[Source] in_mod[[Input Modifier]] in_fmt[[Input Format]] out_fmt[[Output Format]] mware[[Middleware]] out_mod[[Output Modifier]] sink[Sink] src -- InputReader --\u003e in_mod in_mod -- InputReader --\u003e in_fmt in_fmt -. JSON string .-\u003e mware mware -. JSON string .-\u003e out_fmt in_fmt -- \"interface{}\" --\u003e out_fmt out_fmt -- OutputWriter --\u003e out_mod out_mod -- OutputWriter --\u003e sink style mware fill:#D55E00 More details on the implementation of each component and the connections between them can be found on their pages in this section.\nSupporting Infrastructure vhs provides several software constructs to implement and manage its data flow and modules.\n flow: Flow is the highest level construct. It contains the input chain and output chains and manages the execution of all the modules for a given vhs session. Defined in flow/flow.go. input: The input construct contains and manages the input chain of a vhs data flow. vhs supports a single input chain per session. Defined in flow/input.go. output: The output construct contains and manages the output chain(s) of a vhs data flow. vhs supports multiple output chains per session. Defined in flow/output.go.  The conceptual arrangement of these constructs is shown in the figure below. In most cases, it should not be necessary to modify these portions of the codebase when adding new data flow components, but a general understanding of these constructs should be helpful for both vhs developers and end users.\ngraph LR src[Source] in_mod[[Input Modifier]] in_fmt[[Input Format]] out_fmt[[Output Format]] out_mod[[Output Modifier]] sink[Sink] src --\u003e in_mod in_mod --\u003e in_fmt in_fmt --\u003e out_fmt out_fmt --\u003e out_mod out_mod --\u003e sink subgraph in [Input] src in_mod in_fmt end subgraph out [Output] out_fmt out_mod sink end subgraph flow [Flow] in out end style in fill:#F0E442 style flow fill:#009E73 style out fill:#56B4E9 Parser: Specifying VHS data flows vhs data flows are defined at runtime with command line flags as described on the reference page (Inputs and Outputs). Internally, these flags are processed by a parser. This parser reads the specified input and output chain descriptions and instantiates a Flow that contains the specified components. All components must register with the parser by calling the appropriate Load... function with the identifying token and the constructor for the component. The parser is implemented in flow/parser.go and component registration with the default Parser is done in cmd/vhs/main.go.\n","excerpt":"Introduction vhs is a network traffic utility that works by chaining …","ref":"/vhs/architecture/","title":"Architecture"},{"body":"A sink component is the termination of an output chain in the vhs data flow. Each output chain must end with a sink. A sink provides a way for data to leave vhs, such as by writing to the standard output, a local file, or a network location, among others. Information on the sinks available in the current release of vhs can be found here: sinks.\nDeveloping a Sink Sinks are the simplest components in vhs. Sinks must conform to the the interface defined in core/sink.go as shown below:\n// Sink is a writable location for output. type Sink io.WriteCloser Example Since a sink is simply an io.WriteCloser, any existing types that conform to this interface can be used a sink. This means that a simple sink can be implemented in only a handful of lines of code, as with the stdout sink, which is implemented in cmd/vhs/main.go in the default parser definition. Since it is so short, it is recreated here:\np.LoadSink(\"stdout\", func(_ session.Context) (flow.Sink, error) { return os.Stdout, nil }) Since os.Stdout conforms to io.WriteCloser, the stdout sink can be implemented as a one-line anonymous function.\nThe gcs sink presents a more complex, real-world example of writing to cloud storage. It is implemented in gcs/gcs.go.\n","excerpt":"A sink component is the termination of an output chain in the vhs data …","ref":"/vhs/architecture/sink/","title":"Sink"},{"body":"Introduction to VHS VHS is a versatile tool for network traffic capture. VHS can be run as a command line tool or be deployed into your Kubernetes cluster as a sidecar, where it can capture traffic to and from your services. Captured traffic can be analyzed to produce live Prometheus metrics or saved for use in offline analysis, load testing, or whatever you can imagine.\n","excerpt":"Introduction to VHS VHS is a versatile tool for network traffic …","ref":"/vhs/","title":"VHS Documentation"},{"body":"","excerpt":"","ref":"/vhs/categories/","title":"Categories"},{"body":"","excerpt":"","ref":"/vhs/tags/","title":"Tags"}]